# üçï Case Study #2 Pizza Runner

## Solution - C. Ingredient Optimisation

### 1. What are the standard ingredients for each pizza?
```sql
SELECT pizza_name,
	pn.pizza_id,
	pt.topping_id,
	topping_name
FROM pizza_runner.pizza_names pn
JOIN (
	SELECT pizza_id,
		CAST(unnest(string_to_array(toppings, ','))as INTEGER)as topping_id
	FROM pizza_runner.pizza_recipes
) pr ON pn.pizza_id = pr.pizza_id
JOIN pizza_runner.pizza_toppings pt ON pr.topping_id = pt.topping_id
ORDER BY 1,2,3;
```
### Steps:
- Use `JOIN` to merge and return only rows that have matching values in both tables
- Create `Subquery` and Use `string_to_array(exclusions, ',')` to splits a comma-separated string (exclusions) into an array of substrings using the comma (',') as the delimiter. For example, if exclusions is 'A,B,C', the result will be an array ['A', 'B', 'C']
- Use `unnest()` to expands an array into a set of rows. It takes the array produced by string_to_array() and converts it into a result set with one row for each element of the array. Each element becomes a separate row in the result set, as topping_id
- Use `CAST()` to convert datatype into INTEGER
----

### 2. What was the most commonly added extra?
```sql
SELECT c.topping_id,
	COUNT(1)as number_extras,
	topping_name
FROM (
	SELECT pizza_id,
		CAST(UNNEST(string_to_array(extras, ',')) AS INTEGER) AS topping_id
	FROM customer_orders_cleaned
)c
JOIN pizza_runner.pizza_toppings pt ON c.topping_id = pt.topping_id
GROUP BY 1,3
ORDER BY 1
```
### Steps:
- Use `JOIN` to merge and return only rows that have matching values in both tables
- Create `Subquery` and Use `string_to_array(exclusions, ',')` to splits a comma-separated string (extras) into an array of substrings using the comma (',') as the delimiter. For example, if exclusions is 'A,B,C', the result will be an array ['A', 'B', 'C']
- Use `unnest()` to expands an array into a set of rows. It takes the array produced by string_to_array() and converts it into a result set with one row for each element of the array. Each element becomes a separate row in the result set, as topping_id
- Use `CAST()` to convert datatype into INTEGER
- Use `COUNT()` to calculate the most commonly added extra

So, We get the most commonly added extra was bacon, 4 of them

----

## 3. What was the most common exclusion?
```sql
SELECT c.topping_id,
	COUNT(1)as number_exclusions,
	topping_name
FROM (
	SELECT pizza_id,
		CAST(UNNEST(string_to_array(exclusions, ',')) AS INTEGER) AS topping_id
	FROM customer_orders_cleaned
)c
JOIN pizza_runner.pizza_toppings pt ON c.topping_id = pt.topping_id
GROUP BY 1,3
ORDER BY 1;
```
### Steps:
- Use `JOIN` to merge and return only rows that have matching values in both tables
- Create `Subquery` and Use `string_to_array(exclusions, ',')` to splits a comma-separated string (exclusions) into an array of substrings using the comma (',') as the delimiter. For example, if exclusions is 'A,B,C', the result will be an array ['A', 'B', 'C']
- Use `unnest()` to expands an array into a set of rows. It takes the array produced by string_to_array() and converts it into a result set with one row for each element of the array. Each element becomes a separate row in the result set, as topping_id
- Use `CAST()` to convert datatype into INTEGER
- Use `COUNT()` to calculate the most common exclusion

So, we get the most common exclusion was cheese, 4 of them

----

### 4. Generate an order item for each record in the customers_orders table in the format of one of the following:
  - Meat Lovers
  - Meat Lovers - Exclude Beef
  - Meat Lovers - Extra Bacon
  - Meat Lovers - Exclude Cheese, Bacon - Extra Mushroom, Peppers

### STEP 1 :
- Create a temporary table `extra_exclusions`
- Use `split_part()` to split a string (exclusions & extras) into substrings based on a delimiter `(',' in this case)`
- Retrieves a specific substring specified by the field position

```sql
DROP TABLE IF EXISTS extras_exclusions;
    CREATE TEMP TABLE extras_exclusions AS
with CTE_1 as(	
	SELECT order_id,
		pizza_id,
		split_part(exclusions, ',' ,1)as exclusions_1,
		split_part(exclusions, ',' ,2)as exclusions_2,
		split_part(extras, ',' ,1)as extras_1,
		split_part(extras, ',' ,2)as extras_2
	FROM customer_orders_cleaned
)
	SELECT c.order_id,
		c.pizza_id,
		pizza_name,
		exclusions_1 :: INTEGER,
		pt1.topping_name as topping_exclude_1,
			CASE WHEN exclusions_2 = '' THEN NULL
		     		ELSE TRIM(exclusions_2) :: INTEGER
			END as exclusions_2,
		pt1.topping_name as topping_exclude_2,
		extras_1 :: INTEGER,
		pt2.topping_name as topping_extras_1,
			CASE WHEN extras_2 = '' THEN NULL
		     		ELSE TRIM(extras_2) :: INTEGER
			END as extras_2,
		pt2.topping_name as topping_extras_2
	FROM CTE_1 c
	LEFT JOIN pizza_runner.pizza_names pn on c.pizza_id = pn.pizza_id
	LEFT JOIN pizza_runner.pizza_toppings pt1 on c.exclusions_1 :: integer = pt1.topping_id
	LEFT JOIN pizza_runner.pizza_toppings pt2 on c.extras_1 :: integer = pt2.topping_id
	ORDER BY 1,2;
 ```

### STEP 2 :
- Create `CTE` to give the details topping_name for exclusion_2 and extras_2
- Use `CONCAT()` to concat the column 

```sql
WITH CTE_2 AS(
	SELECT *
	FROM extras_exclusions
),
CTE_3 AS(
	SELECT order_id,
		pizza_id,
		pizza_name,
			CASE WHEN exclusions_1 IS NULL THEN CONCAT(topping_exclude_1, ' ', topping_exclude_2)
			     WHEN exclusions_2 IS NULL THEN CONCAT('- Exclude', ' ', topping_exclude_1)
			     ELSE CONCAT('- Exclude', ' ', topping_exclude_1, ' ', topping_exclude_2) 
			END AS exclusions,
			CASE WHEN extras_1 IS NULL THEN CONCAT(topping_extras_1, ' ', topping_extras_2)
			     WHEN extras_2 IS NULL THEN CONCAT('- Extra', ' ', topping_extras_1)
			     ELSE CONCAT('- Extra', ' ', topping_extras_1, ' ', topping_extras_2)
			END AS extras
	FROM CTE_2
)
	SELECT order_id,
		CONCAT(pizza_name, ' ', exclusions, ' ', extras) as order_detail
	FROM CTE_3;
```
----

## 5. Generate an alphabetically ordered comma separated ingredient list for each pizza order from the customer_orders table and add a 2x in front of any relevant ingredients.
    For example: "Meat Lovers: 2xBacon, Beef, ... , Salami"
    
-- Step 1 : Fixing customer_orders table
```sql
DROP TABLE IF EXISTS customer_orders_cleaned;
CREATE TEMP TABLE customer_orders_cleaned AS
	SELECT ROW_NUMBER() OVER(ORDER BY order_id,customer_id)as row_number,	
		order_id,
		customer_id,
		pizza_id,
	CASE WHEN exclusions = '' THEN NULL
	     WHEN exclusions = 'null' THEN NULL
	     ELSE exclusions
	END as exclusions,
	CASE WHEN extras = '' THEN NULL
	     WHEN extras = 'null' THEN NULL
	     ELSE extras
	END as extras,
		order_time
FROM customer_orders;
```

-- Step 2 : Create temp table of standard ingredients for each pizza, for each order, each customer (join customer_orders_cleaned)
```sql
DROP TABLE IF EXISTS pizza_recipes_unstacked;
CREATE TEMP TABLE pizza_recipes_unstacked AS
SELECT row_number,
	order_id,
	customer_id,
	t1.pizza_id,
	pizza_name,
	t2.topping_id,
	topping_name
FROM pizza_names t1
JOIN (
	SELECT pizza_id,
		CAST(UNNEST(string_to_array(toppings, ',')) AS INTEGER) as topping_id
	FROM pizza_recipes
)t2 ON t1.pizza_id = t2.pizza_id
JOIN pizza_toppings t3 ON t2.topping_id = t3.topping_id
RIGHT JOIN customer_orders_cleaned t4 ON t1.pizza_id = t4.pizza_id
ORDER BY 1,2,3;
```

Now we get temp table of standard ingredients for each pizza, for each order, each customer

Then we need to specify pizza order with add extras and exclusions :

-- Step 3 : Unpivot exclusions and extras then replace null with 0 using coalesce
```sql
CREATE TEMP TABLE order_exclusions AS
	SELECT row_number,
		order_id,
		customer_id,
		t1.pizza_id,
		pizza_name,
		CAST(UNNEST(string_to_array(coalesce(exclusions, '0'), ',')) AS INTEGER) as exclusions
	FROM customer_orders_cleaned t1
	JOIN pizza_names t2 ON t1.pizza_id = t2.pizza_id
	ORDER BY 1,2,3;
```
-- 
```sql
CREATE TEMP TABLE order_extras AS
	SELECT row_number,
		order_id,
		customer_id,
		t1.pizza_id,
		pizza_name,
		CAST(UNNEST(string_to_array(COALESCE(extras, '0'), ','))AS INTEGER)as extras
	FROM customer_orders_cleaned t1
	JOIN pizza_names t2 ON t1.pizza_id = t2.pizza_id
	ORDER BY 1,2,3;		
```

-- Step 4 : JOIN pizza_recipes_unstacked with order_extras using UNION function 

So we can specify specify pizza order with add extras for each order, each customer
```sql
CREATE TEMP TABLE pizzas_details AS
	WITH first_layer AS(
		SELECT row_number,
			order_id,
			customer_id,
			pizza_id,
			pizza_name,
			topping_id
		FROM pizza_recipes_unstacked
		 UNION ALL
		SELECT *
		FROM
		  order_extras
		WHERE
		  extras != 0
	)
		SELECT row_number,
			order_id,
			customer_id,
			pizza_id,
			pizza_name,
			t1.topping_id,
			topping_name
		FROM first_layer t1
-- left join with pizza_topping because we cant union 2 tables above with topping_name
		LEFT JOIN pizza_toppings t2 ON t1.topping_id = t2.topping_id
		ORDER BY 1,2,3,4;
```

		
-- Step 5 : let's  now reshape the data to answer the question

Firstly, we need to make table counting_ingredient
```sql
	with counting_table AS(
		SELECT row_number,
			order_id,
			customer_id,
			pizza_id,
			pizza_name,
			topping_id,
			topping_name,
			COUNT(topping_id)as count_ingredient
		FROM pizzas_details
		GROUP BY 1,2,3,4,5,6,7
	),
	
	text_table as(
-- Secondly, create text_table so we can add a 2x in front of any relevant ingredients
		SELECT row_number,
			order_id,
			pizza_id,
			pizza_name,
			topping_id,
		   CASE WHEN count_ingredient = 1 THEN topping_name
			ELSE CONCAT(count_ingredient, 'x',topping_name)
		   END as ingredient_count
		FROM counting_table
	),
	
	group_text as(
-- Furthermore, create group_table so we can get ingredient list separated with comma
	SELECT row_number,
		order_id,
		pizza_id,
		pizza_name,
		STRING_AGG(ingredient_count, ',')as recipe
	FROM text_table
	GROUP BY 1,2,3,4
	)
	
-- Last but not a least, Generate an alphabetically ordered comma separated ingredient list for each pizza order
	SELECT row_number,
		order_id,
		CONCAT(pizza_name, ':', recipe)as ingredient_list
	FROM group_text
	GROUP BY 1,2,3
	ORDER BY 1,2

```

## 6. What is the total quantity of each ingredient used in all delivered pizzas sorted by most frequent first?
-- Using data from pizzas_table above
```sql
SELECT topping_id,
		topping_name as ingredient_used,
		COUNT(topping_id)as total_quantity
FROM pizzas_details
GROUP BY 1,2
ORDER BY 1
```
